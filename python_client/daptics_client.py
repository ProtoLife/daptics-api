#!/usr/bin/env python3

"""DapticsClient - A Python client for the Daptics GraphQL API.

See comments and docstrings for the DapticsClient class in the code below
for suggestions for using this class. For additional help or information,
please visit or contact Daptics.

On the web at https://daptics.ai
By email at support@daptics.ai

Daptics API Version 0.7.2
Copyright (c) 2019 Daptics Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), the
rights to use, copy, modify, merge, publish, and/or distribute, copies of
the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

You do not have the right to sub-license or sell copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""


import csv
import gql
import gql.transport.requests
import os
import json
import pprint
import random
import requests
import requests.auth
import time
import sys
from time import sleep

class TokenAuth(requests.auth.AuthBase):
    """A callable authentication object for the Python "requests" moudule.
    If acess token is set, add a "Bearer" authorization header to the HTTP request.

    # Attributes
    token (str):
        An access token obtained from the API for the authenticated user.
    """
    def __init__(self):
        self.token = None

    def __call__(self, r):
        """Insert the authorization header as a bearer token.
        """
        if self.token is not None:
            r.headers['Authorization'] = 'Bearer ' + self.token
        return r


class NoCurrentTaskError(Exception):
    def __init__(self):
        self.message = 'There is no current task active in the session.'

class TaskTypeError(Exception):
    def __init__(self, type_):
        self.message = 'The current task is not of the the requested {} task type.'.format(type_)

class TaskTimeoutError(Exception):
    def __init__(self):
        self.message = 'The current task did not complete within the timeout duration.'

class TaskFailedError(Exception):
    def __init__(self, type_):
        self.message = 'The {} task failed to return a valid result.'.format(type_)

class SessionParametersNotValidatedError(Exception):
    def __init__(self):
        self.message = 'The session parameters have not been validated.'

class InvalidParameterError(Exception):
    def __init__(self, space_type, param):
        self.message = 'Invalid parameter for space type {}: {}.'.format(space_type, param)

class NextGenerationError(Exception):
    def __init__(self, gen):
        self.message = 'The next requested generation must be {}.'.format(gen)

class CsvFileEmptyError(Exception):
    def __init__(self, fname):
        self.message = 'No rows were found in the file {}.'.format(fname)

class CsvNoDataRowsError(Exception):
    def __init__(self, fname):
        self.message = 'No data rows were found in the file {}.'.format(fname)

class SpaceOrDesignRequiredError(Exception):
    def __init__(self):
        self.message = 'To generate random experiments you must supply experimental space or design.'


class DapticsClient(object):
    """A Python gql client for maintaining the state of a Daptics optimization session.
    Between API invocations, data such as the user id, access token, session id,
    last generated design, etc. are retained in the object's attributes.

    # Attributes
    host (str):
        The host part of the API endpoint.

    api_url (str):
        The full API endpoint URL.

    pp (pprint.PrettyPrinter):
        Used for printing dict output.

    gql (gql.Client):
        The gql.Client object used to make GraphQL requests to the API.

    auth (TokenAuth):
        Used to insert the required authorization header in API requests. The
        auth object's `token` attribute is set by the `login` method.

    user_id (str):
        The user id for the authenticated user, set by the `login` method.

    session_id (str):
        The session id for a connected PDT session, as set by the `create_session` method.

    current_task (dict):
        Information about a running task in the session.

    gen (int):
        The design "generation number" for the session. This is -1 for a new session,
        0 when the session's experimental space has been validated, and greater than
        zero when a design has been generated by the system.

    remaining (int):
        If not None, the number of possible generations that can be generated until
        the entire design space has been explored.

    completed (boolean):
        A flag indicating whether the design space has been completely explored.

    initial_params (dict):
        The experimental space and other information as initially returned by the
        `create_session` method.

    space (dict):
        The experimental space as updated by the result of the "save experimental space" task.

    design (dict):
        The current generated design, as updated by the result of a "generate design" task.

    experiments_history (list):
        All the experiments and responses that have been simulated, as updated by the result
        of a "simulate" task, represented as a list of Python dicts.
    """
    def __init__(self, host):
        """Initialize a new DapticsClient object.

        # Arguments
        host (str):
            The host part of the API endpoint. Example: `http://localhost:4041`
        """
        self.host = host
        self.api_url = '{0}/api'.format(host)
        self.pp = pprint.PrettyPrinter(indent=4)
        self.gql = None
        self.auth = TokenAuth()
        self.user_id = None
        self.session_id = None
        self.current_task = None
        self.gen = -1
        self.remaining = None
        self.completed = False
        self.initial_params = None
        self.validated_params = None
        self.design = None
        self.experiments_history = None

    def print(self):
        """Print out debugging information about the session.
        """
        print('host = ', self.host)
        print('user_id = ', self.user_id)
        print('session_id = ', self.session_id)
        print('current_task = ', self.current_task)
        print('gen = ', self.gen)
        print('remaining = ', self.remaining)
        print('completed = ', self.completed)
        if self.validated_params is not None:
            print('Experimental Space Definition:')
            for x in self.validated_params:
                if x == 'space':
                    sp = self.validated_params[x]
                    for y in sp:
                        if y == 'table':
                            print('\t ESD Data:')
                            print('\t\t', sp['table']['colHeaders'])
                            for z in sp['table']['data']:
                                zz = [z[i] for i in range(len(z)) if z[i] != '']
                                print('\t\t', zz)
                        else:
                            print('\t', y, ':  ', sp[y])
                else:
                    print('\t', x, ':  ', self.validated_params[x])
        else:
            print('Experimental Space Definition: None')

        if self.design is not None:
            print('Design:')
            print(self.design['table']['colHeaders'])
            for dd in self.design['table']['data']:
                print(dd)
        else:
            print('Design: None')

        if self.experiments_history is not None:
            print('Experiments History:')
            max_gen = len(self.experiments_history)
            for gen, exp in enumerate(self.experiments_history):
                if exp is not None:
                    print('\tGeneration {}:'.format(gen))
                    print('\t', exp['table']['colHeaders'])
                    for dd in exp['table']['data']:
                        print('\t', dd)
                else:
                    print('\tGeneration {}: None'.format(gen))
        else:
            print('Experiments History: None')


    def call_api(self, document, vars, timeout=None):
        """Perform validation on the gql query or mutation document and then
        execute the query. We cannot call `self.gql.execute` directly, because it converts
        'errors' returned into an Exception. We want to preserve the 'errors'
        if they exist, and also return the data.

        # Arguments
        fname (str):
            The file path to save the client state to.

        # Returns
        (dict, dict):
            A tuple containing two `dicts`: The first element is the `data` component
            of the GraphQL response, a Python dict with `currentTask`, and the second
            element is the `errors` component of the GraphQL response. Either `data` or
            `errors` may be None.
        """

        if self.gql.schema:
            self.gql.validate(document)

        try:
            result = self.gql._get_result(document, variable_values=vars, timeout=timeout)
            return (result.data, result.errors)
        except Exception as e:
            return (None, [{'message': str(e)}])

    def error_messages(self, errors):
        """Extract the `message` values from the errors list returned in a GraphQL response.

        # Arguments
        errors (list):
            The list of GraphQL errors. Each error must have a `message` value, and
            can optionally have `key`, `path` and `locations` values.

        # Returns
        str or list:
            The message (or messages) extracted from the GraphQL response.
        """
        messages = []
        for e in errors:
            if e and 'message' in e:
                if 'key' in e:
                    messages.append('{} {}'.format(e['key'], e['message']))
                else:
                    messages.append(e['message'])

        if len(messages) == 0:
            return 'No error information is available.'
        elif len(messages) == 1:
            return messages[0]
        return messages

    def save(self, fname):
        """Save the user and session id to a JSON file.

        # Arguments
        fname (str):
            The file path to save the client state to.

        # Returns
        Nothing
        """
        with open(fname, 'w') as outfile:
            data = {
                'user_id': self.user_id,
                'token': self.auth.token,
                'session_id': self.session_id
            }
            json.dump(data, outfile, ensure_ascii=False, indent=4)

    def load(self, fname):
        """Restore a previously saved client from a JSON file.

        # Arguments
        fname (str):
            The file path to restore the client state from.

        # Returns
        Nothing
        """
        self.auth = TokenAuth()
        self.user_id = None
        self.session_id = None
        self.current_task = None
        self.gen = -1
        self.remaining = None
        self.completed = False
        self.initial_params = None
        self.validated_params = None
        self.design = None
        with open(fname, 'r') as infile:
            data = json.load(infile)
            if 'user_id' in data and data['user_id'] is not None:
                self.user_id = data['user_id']
                if 'token' in data and data['token'] is not None:
                    self.auth.token = data['token']
                if 'session_id' in data and data['session_id'] is not None:
                    self.session_id = data['session_id']

    def connect(self):
        """Create an HTTP transport instance from the client's `api_url` attribute,
        and attempt to connect to the introspection interface. The gql.Client
        value is stored in the client's `gql` attribute.

        # Returns
        Nothing

        # Raises
        requests.ConnectionError:
            If the connection cannot be made.
        """
        if self.gql is None:
            http = gql.transport.requests.RequestsHTTPTransport(
                self.api_url, auth=self.auth, use_json=True)
            self.gql = gql.Client(transport=http, fetch_schema_from_transport=True)

    def login(self, email, password):
        """Authenticate to a user record in the database as identified in the client's
        `email` and `password` attributes, and create an access token.

        # Arguments
        email (str):
            The email adddress of the database user that will be used for authentication.
        password (str):
            The cleartext password of the database user that will be used for authentication.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `login` and/or
            `errors` keys. On successful authentication, the user id and access token
            are stored in the client's `user_id` and `auth` attributes.
        """
        vars = {
            'email': email,
            'password': password
        }

        # The 'login' mutation authenticates a user's email and password and returns
        # an access token that self.auth will then use to add an Authorization
        # header, required for session queries and mutations.
        doc = gql.gql("""
mutation Login($email:String!, $password:String!) {
    login(email:$email, password:$password) {
        token user {
            userId
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'login' in data and data['login'] is not None:
            self.auth.token = data['login']['token']
            self.user_id = data['login']['user']['userId']
        return data

    def create_session(self, name, description):
        """Create a new PDT session.

        # Arguments
        name (str):
            The unique name for the session among the authenticated user's sessions.
        description (str):
            A description for the session.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `createSession` and/or
            `errors` keys. On successful creation, the session id and initial parameters
            are stored in the client's `session_id` and `initial_params` attributes.
        """
        vars = {
            'session': {
                'userId': self.user_id,
                'name': name,
                'description': description,
                'demo': False
            }
        }

        # The 'createSession' mutation will add a new session to the backend's database,
        # copy runtime files to a fresh Rserve session directory on the Rserve filesystem,
        # start the session and return initial session information.
        doc = gql.gql("""
mutation CreateSession($session:NewSessionInput!) {
    createSession(session:$session) {
        sessionId version tag name description host path active demo campaign {
            gen remaining completed
        }
        params {
            validated populationSize replicates designCost space {
                type totalUnits table {
                    colHeaders data
                }
            }
        }
    }
}
        """)

        data, errors = self.call_api(doc, vars)
        if data and 'createSession' in data and data['createSession'] is not None:
            self.session_id = data['createSession']['sessionId']
            self.initial_params = data['createSession']['params']
        else:
            print('Problem creating session!')
            print('Error: {}'.format(self.error_messages(errors)))
            print('Hint: session name may have already been taken, in which case choose another one.')
            return None

        return data

    def list_sessions(self):
        """Show all the user's sessions.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `createSession` and/or
        `errors` keys. On successful creation, the session id and initial parameters
        are stored in the client's `session_id` and `initial_params` attributes.
        """

        # The 'sessions' query will return a list of sessions.
        doc = gql.gql("""
query GetSessions {
    sessions { sessionId tag name description active demo }
}
        """)
        return self.gql.execute(doc, variable_values=None)

    def reconnect_session(self, session_id):
        """Find an existing session.

        # Arguments
        session_id (str):
            The session id to find.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `createSession` and/or
            `errors` keys. On successful creation, the session id and initial parameters
            are stored in the client's `session_id` and `initial_params` attributes.
        """
        vars = {
            'sessionId': session_id
        }

        # The 'session' query will return the state of the session.
        doc = gql.gql("""
query GetSession($sessionId:String!) {
    session(sessionId:$sessionId) {
        sessionId version tag name description host path active demo campaign {
            gen remaining completed
        }
        params {
            validated populationSize replicates designCost space {
                type totalUnits table {
                    colHeaders data
                }
            }
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'session' in data and data['session'] is not None:
            session = data['session']
            self.session_id = session['sessionId']
            self.gen = session['campaign']['gen']
            self.remaining = session['campaign']['remaining']
            self.completed = session['campaign']['completed']
            self.initial_params = session['params']
            if self.gen >= 0:
                self.validated_params = session['params']
            else:
                self.validated_params = None
        return data

    def halt_session(self, session_id):
        """Close an connected session, to release all resources.

        # Arguments
        session_id (str):
            The session id to close.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `haltSession` and/or
            `errors` keys. If the call is successful, the 'haltSession' value contains
            these keys:

        action (str):
            The action taken, either 'close' (if the session was connected) or 'none' if
            had already been closed.

        status (str):
            The session status, which should always be 'closed',
        """

        vars = {
            'sessionId': session_id
        }

        doc = gql.gql("""
mutation HaltSession($sessionId:String!) {
    haltSession(sessionId:$sessionId) {
        action status
    }
}
        """)
        return self.gql.execute(doc, variable_values=vars)

    def save_experimental_and_space_parameters(self, params):
        """Start a "save experimental space" task in the session, specifying the
        desired experimental space parameters.

        # Arguments
        params (dict):
            A dictionary containing the experimental space parameters to be
            used for the session. See the Notes section that describes the
            required keys for the `params` dict.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveSessionParameters` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Notes
        Keys for the `params` dict are:

        populationSize (int):
            The number of experiments per replicate. A positive integer.

        replicates (int):
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space (dict):
            The experimental space definition. Keys for the `space` dict are:

        type (str):
            The type of the space, a string, either "factorial" or "mixture".

        totalUnits (int):
            For `mixture` type spaces, this is the mixture constraint parameter,
            a non-negative integer.

        table (dict):
            The (optional) column headers and rows of parameter data.  See
            an example below. the `colHeaders` value is ignored when importing
            or validating the experimental space definition.

        To maintain uniformity, header and data row elements should be
        Python strings, even if they represent numeric values.

        For `mixture` type spaces, there should only be 4 columns of data
        in each row: the name of the parameter, the type of the parameter
        (which must always be the string "unit"), the minimum value of the
        parameter (a non-negative integer) and the maximum value of the
        parameter (a positive integer, less than or equal to the `totalUnits`
        constraint parameter).

        For `factorial` type spaces, there must be at least 4 columns of data
        in each row: the name of the parameter, the type of the parameter
        (a string, either "numerical" or "categorical"), and at least
        two possible distinct values that the parameter can have in an experiment.
        Different parameters can have either 2 or more than 2 possible values.
        The rows must be all be of the same size, so make sure to pad the
        rows with fewer values with empty strings at the end.

        # Examples
        Here is a mixture space design that will have enough combinations to be
        validated by the backend.

        ```python
        >>> params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'mixture',
                'totalUnits': 25,
                'table': {
                    'colHeaders':
                        [ 'Name', 'Type', 'Min', 'Max' ],
                    'data': [
                        [ 'param1', 'unit', '1', '10' ],
                        [ 'param2', 'unit', '2', '10' ],
                        [ 'param3', 'unit', '4', '8' ],
                        [ 'param4', 'unit', '2', '5' ]
                    ]
                }
            }
        }
        ```

        Here is a factorial space design that will have enough combinations to be
        validated by the backend.

        ```python
        >>> params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'factorial',
                'table': {
                    'colHeaders':
                        [ 'Name', 'Type', 'Value.1', 'Value.2', 'Value.3', 'Value.4' ],
                    'data': [
                        [ 'param1', 'numerical', '0', '1', '2', '3' ],
                        [ 'param2', 'numerical', '2', '3',  '',  '' ],
                        [ 'param3', 'numerical', '0', '1', '2',  '' ],
                        [ 'param4', 'numerical', '0', '1', '2', '3' ]
                    ]
                }
            }
        }
        ```
        """

        col_headers = self.space_table_column_names(params['space'])
        params['space']['table']['colHeaders'] = col_headers
        vars = {
            'sessionId': self.session_id,
            'params': params
        }

        # The 'saveSessionParameters' mutation must be run to validate the
        # user's experimental design. The mutation will return errors if the
        # parameters or space are not valid (don't generate enough complexity, etc.).
        # If the parameters are valid, information about the long running 'space'
        # task is returned, and the user should poll until the task has completed.
        doc = gql.gql("""
mutation CreateSpaceTask($sessionId:String!, $params:SessionParametersInput!) {
    saveSessionParameters(sessionId:$sessionId, params:$params) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveSessionParameters' in data and data['saveSessionParameters'] is not None:
            self.current_task = data['saveSessionParameters']
            self.current_task['pollRetries'] = 0
        return data

    def save_experimental_and_space_parameters_csv(self, fname, params):
        """Start a "save experimental space" task in the session, specifying the
        desired experimental space parameters. The experimental space is
        read from a CSV file.

        # Arguments
        fname (str):
            The location on the filesystem for a CSV file that will define
            the experimental space definition. See the Examples section
            below for an example.

        params (dict):
            A dictionary containing the experimental space parameters to be
            used for the session. See the Notes section for more information.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveSessionParameters` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Raises
        csv.Error:
            If the specified CSV file is incorrectly formatted.

        # Notes
        Keys for the `params` dict are:

        populationSize (int):
            The number of experiments per replicate. A positive integer.

        replicates (int):
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space (dict):
            The experimental space definition. Keys for the `space` dict are:

        type (str):
            `factorial` or `mixture`

        # Examples
        Here is a space design that will have enough combinations to be
        validated by the backend.

        ```python
        >>> params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'factorial',
            }
        }
        ```

        The contents of an example CSV file for a `factorial` space might be:

        ```
        param1,numerical,0,1,2,3
        param2,numerical,2,3,4,
        param3,numerical,0,1,,
        param4,numerical,0,1,2,3
        ```

        Each parameter row in a factorial space definition should have the same
        number of columns.  Parameter rows with fewer than the maximum number of values
        should have the empty columns at the end of the row, as shown above.

        The contents of an example CSV file for a `mixture` space might be:

        ```
        param1,unit,0,10
        param2,unit,5,10
        param3,unit,0,10
        param4,unit,0,5
        ```

        Each parameter fow in a mixture space defintion must specify a minimum and
        maximum unit volume, as shown above.

        Do not supply a header row for the space definition (for any type), just the parameter
        rows.
        """

        param_rows = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            param_rows = [r for r in reader]
        params['space']['table'] = { 'data': param_rows }
        return self.save_experimental_and_space_parameters(params)

    def save_initial_experiments(self, experiments=None):
        """Save any initial experiments in the session and generate the first design.
        This method must be called to generate the first design, whether or not any
        experiments are submitted. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        # Arguments
        experiments (dict): or None (default)
            If provided, a "table" of initial experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Examples
        Here's an example of an experiments table:

        ```python
        >>> experiments = {
            'colHeaders': ['param1', 'param2', 'param3', 'param4', 'Response'],
            'data': [
                ['0', '4', '1', '1', '3.25'],
                ['1', '4', '1', '1', '4.5']
            ]
        }
        ```
        """

        if experiments is None:
            space = self.get_validated_experimental_space()
            experiments = self.experiments_table_template(space)
        vars = {
            'sessionId': self.session_id,
            'experiments': {
                'gen': 0,
                'table': experiments
            }
        }

        # The 'saveExperiments' mutation sends any initial or designed experiment
        # responses. For this demo we don't send any initial experiments.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation InitialExperiments($sessionId:String!, $experiments:ExperimentsInput!) {
    saveExperiments(sessionId:$sessionId, experiments:$experiments) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveExperiments' in data and data['saveExperiments'] is not None:
            self.current_task = data['saveExperiments']
            self.current_task['pollRetries'] = 0
        return data

    def save_initial_experiments_csv(self, fname):
        """Save any initial experiments in the session and generate the first design.
        This method must be called to generate the first design, whether or not any
        experiments are submitted. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        # Arguments
        fname (str):
            The location on the filesystem for a CSV file that will define
            the intial experiments. See the Examples section
            below for an example.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Raises
        csv.Error:
            If the specified CSV file is incorrectly formatted.

        # Examples
        Here are the contents for an initial experiments file, defining two initial
        experiments. A header row must be provided, the columns in the header row
        must match the names of the parameters defined by the experimental space definition
        exactly, and a final column named `Response` must be filled with the results
        of each experiment row.

        ```
        param1,param2,param3,param4,Response
        0,4,1,1,3.25
        1,4,1,1,4.5
        ```
        """

        experiments = None
        if fname is not None:
            header_and_experiments = []
            with open(fname, newline='') as csvfile:
                reader = csv.reader(csvfile, delimiter=',')
                header_and_experiments = [r for r in reader]
            if len(header_and_experiments) > 0:
                experiments = {
                    'colHeaders': header_and_experiments[0],
                    'data': header_and_experiments[1:]
                }
            else:
                raise CsvFileEmptyError(fname)
        return self.save_initial_experiments(experiments)

    def get_experiments(self, gen=None):
        """Get the designed or completed experiments for the current or any
        previous generation.

        # Arguments
        gen (int):
            The generation number to search for. Use 0 to specify initial
            experiments. Use None to search for the last designed generation.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `experiments` and/or
            `errors` keys. If `gen` is the current, non-zero generation number,
            updates the client's `design` attribute, so this method can be used to
            find the current design. The value at the `experiments` key is a Python
            dict with these keys:

        validated (bool):
            True if these experiments have been validated.

        hasResponses (bool):
            True if at least some of these experiments have responses.

        designRows (int):
            The number of rows of experiments that were designed. Rows after the `designRows`
            are "extra" experiments.

        table (dict):
            A Python dict with `colHeaders` and `data` values, representing the
            experiments submitted or designed for the generation.
        """

        if gen is None:
            gen = self.gen
        vars = {
            'sessionId': self.session_id,
            'gen': gen
        }
        doc = gql.gql("""
query GetExperiments($sessionId:String!, $gen:Int!){
    experiments(sessionId:$sessionId, gen:$gen) {
        validated hasResponses designRows table {
            colHeaders data
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if gen == self.gen and gen > 0 \
            and 'experiments' in data and data['experiments'] is not None:
            self.design = data['experiments']
        return data

    def get_experiments_history(self):
        """Get all of the experiments and any responses for all the generations in the session.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `experimentsHistory` and/or
            `errors` keys. Also updates the client's `experiments_history` attribute.
            The `experimentsHistory` value is either None if no experiments have been submitted or
            designed, or a list. Each item in the list is either None, or a Python dict that
            represents a generation. The first item in the list is generation "zero",
            the initial experiments. If a generation is available (non None), it is a Python
            dict with the following keys:

        gen (int):
            The generation number (zero meaning initial experiments).

        validated (bool):
            True if these experiments have been validated.

        hasResponses (bool):
            True if at least some of these experiments have responses.

        designRows (int):
            The number of rows of experiments that were designed. Rows after the `designRows`
            are "extra" experiments.

        table (dict):
            A Python dict with `colHeaders` and `data` values, representing the
            experiments submitted or designed for the generation.
        """

        vars = {
            'sessionId': self.session_id
        }
        doc = gql.gql("""
query GetExperimentsHistory($sessionId:String!){
    experimentsHistory(sessionId:$sessionId) {
        gen validated hasResponses designRows table {
            colHeaders data
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'experimentsHistory' in data:
            self.experiments_history = data['experimentsHistory']
        return data

    def simulate_experiment_responses(self, experiments = None):
        """Generate values for the "Response" column.  The values are a
        substitute for actual experimental results, computed with a
        synthetic data generator that takes as an input each
        experiment (i.e. each row of the experiments argument) and
        gives as output a single number, added as a 'Response'.  The
        data generator samples a complex surface, constructed to have
        several peaks that are randomly placed in the space.  There is
        a global optimum (highest peak), but optimization runs often
        will find one of the lower peaks.

        # Arguments
        experiments (dict):
            A "table" of experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `simulateExperiments` and/or
            `errors` keys.
        """

        vars = {
            'sessionId': self.session_id
        }
        if experiments is not None:
            vars['experiments'] = experiments

        # A 'simulateResponses' mutation may supply an `experiments` table.
        doc = gql.gql("""
mutation SimulateResponses($sessionId:String!, $experiments:DataFrameInput) {
    simulateResponses(sessionId:$sessionId, experiments:$experiments) {
        validated designRows table { colHeaders data }
    }
}
        """)
        return self.gql.execute(doc, variable_values=vars)

    def simulate_experiment_responses_csv(self, fname):
        """Generate values for the "Response" column.  The values are a
        substitute for actual experimental results, computed with a
        synthetic data generator that takes as an input each
        experiment (i.e. each row of the experiments argument) and
        gives as output a single number, added as a 'Response'.  The
        data generator samples a complex surface, constructed to have
        several peaks that are randomly placed in the space.  There is
        a global optimum (highest peak), but optimization runs often
        will find one of the lower peaks.

        # Arguments
        fname (str):
            The location on the filesystem for a CSV file that will define
            the parameters for designed and any extra experiments.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `simulateExperiments` and/or
            `errors` keys.
        """

        experiments = None
        header_and_experiments = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            header_and_experiments = [r for r in reader]
        if len(header_and_experiments) > 1:
            experiments = {
                'colHeaders': header_and_experiments[0],
                'data': header_and_experiments[1:]
            }
        else:
            raise CsvNoDataRowsError(fname)
        return self.simulate_experiment_responses(experiments)

    def save_experiment_responses(self, experiments):
        """Save designed or extra experiments for the last designed generation in the session,
        and generate the next design. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        # Arguments
        experiments (dict):
            A "table" of experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment. There must be at least as many rows as
            the current design has, and the parameter values for these rows
            must match the design exactly. Additional "extra" experiment
            rows can also be provided.

        # Returns
        dkct:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Examples
        Here's an expamle of an experiments table:

        ```python
        >>> experiments = {
            'colHeaders': ['param1', 'param2', 'param3', 'param4', 'Response'],
            'data': [
                ['0', '4', '1', '1', '3.25'],
                ['1', '4', '1', '1', '4.5'],
                ... etc, matching generated design rows
            ]
        }
        ```
        """

        vars = {
            'sessionId': self.session_id,
            'experiments': {
                'gen': self.gen,
                'table': experiments
            }
        }

        # A 'saveExperiments' mutation for a designed generation ('gen' > 0) requires
        # responses for the designed generation (and any optional additional non-designed
        # experiments and their responses), sent in the 'table' variable.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation SaveExperiments($sessionId:String!, $experiments:ExperimentsInput!) {
    saveExperiments(sessionId:$sessionId, experiments:$experiments) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveExperiments' in data and data['saveExperiments'] is not None:
            self.current_task = data['saveExperiments']
            self.current_task['pollRetries'] = 0
        return data

    def save_experiment_responses_csv(self, fname):
        """Save designed or extra experiments for the last designed generation in the session,
        and generate the next design. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        # Arguments
        fname (str):
            The location on the filesystem for a CSV file that will define
            the results of the designed and any extra experiments. See the Examples section
            below for an example.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Examples
        A header row must be provided, the columns in the header row
        must match the names of the parameters defined by the experimental space definition
        exactly, and a final column named `Response` must be filled with the results
        of each experiment row.

        ```
        param1,param2,param3,param4,Response
        0,4,1,1,3.25
        1,4,1,1,4.5
        ```

        Each non-header row in the file represents an individual experiment. There must be at
        least as many experiment rows as the current design has, and the parameter values
        for these rows must match the design exactly. Additional "extra" experiment
        rows can also be provided.
        """
        experiments = { 'colHeaders': '', 'data': [] }
        header_and_experiments = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            header_and_experiments = [r for r in reader]
        if len(header_and_experiments) > 1:
            experiments['colHeaders'] = header_and_experiments[0]
            experiments['data'] = header_and_experiments[1:]
        else:
            raise CsvNoDataRowsError(fname)
        return self.save_experiment_responses(experiments)

    def finalize_campaign(self, experiments):
        """Save designed and extra experiments for the final generation in the session.
        If the experments are successfully validated against the
        experimental space parameters, a "finalize campaign" task is started.

        # Arguments
        experiments (dict):
            A "table" of experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment. There must be at least as many rows as
            the current design has, and the parameter values for these rows
            must match the design exactly. Additional "extra" experiment
            rows can also be provided.

        # Returns
        dkct:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Examples
        Here's an expamle of an experiments table:

        ```python
        >>> experiments = {
            'colHeaders': ['param1', 'param2', 'param3', 'param4', 'Response'],
            'data': [
                ['0', '4', '1', '1', '3.25'],
                ['1', '4', '1', '1', '4.5'],
                ... etc, matching generated design rows
            ]
        }
        ```
        """

        vars = {
            'sessionId': self.session_id,
            'experiments': {
                'gen': self.gen,
                'table': experiments
            }
        }

        # A 'finalizeCampaign' mutation for a designed generation ('gen' > 0) requires
        # responses for the designed generation (and any optional additional non-designed
        # experiments and their responses), sent in the 'table' variable.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation FinalizeCampaign($sessionId:String!, $experiments:ExperimentsInput!) {
    finalizeCampaign(sessionId:$sessionId, experiments:$experiments) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'finalizeCampaign' in data and data['finalizeCampaign'] is not None:
            self.current_task = data['finalizeCampaign']
            self.current_task['pollRetries'] = 0
        return data

    def finalize_campaign_csv(self, fname):
        """Save designed and extra experiments for the final generation in the session.
        If the experments are successfully validated against the
        experimental space parameters, a "finalize campaign" task is started.

        # Arguments
        fname (str):
            The location on the filesystem for a CSV file that will define
            the results of the designed and any extra experiments. See the Examples section
            below for an example.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `saveExperiments` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Examples
        A header row must be provided, the columns in the header row
        must match the names of the parameters defined by the experimental space definition
        exactly, and a final column named `Response` must be filled with the results
        of each experiment row.

        ```
        param1,param2,param3,param4,Response
        0,4,1,1,3.25
        1,4,1,1,4.5
        ```

        Each non-header row in the file represents an individual experiment. There must be at
        least as many experiment rows as the current design has, and the parameter values
        for these rows must match the design exactly. Additional "extra" experiment
        rows can also be provided.
        """
        experiments = { 'colHeaders': '', 'data': [] }
        header_and_experiments = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            header_and_experiments = [r for r in reader]
        if len(header_and_experiments) > 1:
            experiments['colHeaders'] = header_and_experiments[0]
            experiments['data'] = header_and_experiments[1:]
        else:
            raise CsvNoDataRowsError(fname)
        return self.finalize_campaign(experiments)

    def start_simulation(self, ngens, params):
        """Run a simulation for several design generations, specifying the
        desired experimental space parameters and the number of generations
        to run.

        # Arguments
        ngens (int):
            The number of generations to attempt to design. Must be greater than zero.
            If the experimental space is exhausted the actual number of generations
            designed may be less than this number.

        params (dict):
            A dictionary containing the experimental space parameters to be
            used for the session. See the Notes section that describes the
            required keys for the `params` dict.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `runSimulation` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Notes
        For more examples of how to submit space parameters, please
        see the documentation for the `save_experimental_and_space_parameters` method.
        Keys for the `params` dict are:

        populationSize (int):
            The number of experiments per replicate. A positive integer.

        replicates (int):
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space (dict):
            The experimental space definition. Keys for the `space` dict are:

        type (str):
            The type of the space, a string, either "factorial" or "mixture".

        totalUnits (int):
            For `mixture` type spaces, this is the mixture constraint parameter,
            a non-negative integer.

        table (dict):
            The (optional) column headers and rows of parameter data.  See
            an example below. the `colHeaders` value is ignored when importing
            or validating the experimental space definition.
        """

        vars = {
            'sessionId': self.session_id,
            'ngens': ngens,
            'params': params
        }

        # A 'finalizeCampaign' mutation for a designed generation ('gen' > 0) requires
        # responses for the designed generation (and any optional additional non-designed
        # experiments and their responses), sent in the 'table' variable.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation RunSimulation($sessionId:String!, $ngens:Int!, $params:SessionParametersInput!) {
    runSimulation(sessionId:$sessionId, ngens:$ngens, params:$params) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'runSimulation' in data and data['runSimulation'] is not None:
            self.current_task = data['runSimulation']
            self.current_task['pollRetries'] = 0
        return data

    def start_simulation_csv(self, ngens, fname, params):
        """Run a simulation for several design generations, specifying the
        desired experimental space parameters and the number of generations to run.
        The experimental space is read from a CSV file. If the space parameters
        are successfully validated a "simulate" task is started.

        # Arguments
        ngens (int):
            The number of generations to attempt to design. Must be greater than zero.
            If the experimental space is exhausted the actual number of generations
            designed may be less than this number.

        fname (str):
            The location on the filesystem for a CSV file that will define
            the experimental space definition. See the Examples section
            below for an example.

        params (dict):
            A dictionary containing the experimental space parameters to be
            used for the session.  See the Notes section that describes the
            required keys for the `params` dict.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `runSimulation` and/or
            `errors` keys. If the task was successfully started, the task information is stored
            in the client's `current_task` attribute.

        # Raises
        csv.Error:
            If the specified CSV file is incorrectly formatted.

        # Notes
        For more examples of how to submit space parameters, please
        see the documentation for the `save_experimental_and_space_parameters_csv` method.
        Keys for the `params` dict are:

        populationSize (int):
            The number of experiments per replicate. A positive integer.

        replicates (int):
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space (dict):
            The experimental space definition. Keys for the `space` dict are:

        type (str):
            The type of the space, a string, either "factorial" or "mixture".

        totalUnits (int):
            For `mixture` type spaces, this is the mixture constraint parameter,
            a non-negative integer.
        """

        param_rows = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            param_rows = [r for r in reader]
        params['space']['table'] = { 'data': param_rows }
        return self.start_simulation(ngens, params)

    def poll_for_current_task(self, task_type=None):
        """If there is a currently running task saved in the client, poll the
        session to see if a result is ready.

        # Arguments
        task_type (str):
            `space`, `generate`, or None. If None is supplied (the default), use the
            task id stored in the client.

        # Returns
        (dict, dict):
            A tuple containing two `dicts`: The first element is the `data` component
            of the GraphQL response, a Python dict with `currentTask`, and the second
            element is the `errors` component of the GraphQL response. Either `data` or
            `errors` may be None.

        If the current task was a "save experimental space" task and it successfully completed,
        the client's `gen` attribute is set to zero.

        If the current task was a "generate design" task and it successfully completed,
        the client's `gen` attribute is updated to a number greater than zero, and the
        design is stored in the client's `design` attribute.

        If either type of task completed or failed, the client's `current_task` attribute
        is reset to None.
        """

        retries = 0
        vars = {
            'sessionId': self.session_id,
            'taskId': None,
            'type': None
        }
        if task_type is None:
            task = self.current_task
            if task is None:
                return ( { 'currentTask': None },
                    [ { 'message': 'No currently running task in client.' } ] )
            else:
                retries = task['pollRetries']
                vars['taskId'] = task['taskId']
        else:
            vars['type'] = task_type

        # Saving the experimental and space parameters will start a long running
        # 'space' task. Saving experimental responses will start a long running
        # 'generate' task. This function queries the backend to check the status
        # of the task based on the task type. If the task is still running, we
        # do nothing. If no task is found, or if the task has failed, we assert
        # an error. If the task has completed, we update self.gen
        # for 'space' and 'generate' task results, and save self.design
        # from a 'generate' task result.
        doc = gql.gql("""
query CurrentTask($sessionId:String!, $taskId:String, $type:String) {
    currentTask(sessionId:$sessionId, taskId:$taskId, type:$type) {
        taskId type status startedAt progress {
            message
        }
        errors {
            message category fatalError systemError
        }
        result {
            ... on SpaceTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
            }
            ... on GenerateTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
                experiments {
                    validated designRows table {
                        colHeaders data
                    }
                }
            }
            ... on FinalizeTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
            }
            ... on SimulateTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
                experimentsHistory {
                    gen validated designRows table {
                        colHeaders data
                    }
                }
            }
        }
    }
}
        """)


        data, errors = self.call_api(doc, vars)
        if data and 'currentTask' in data and data['currentTask'] is not None:
            if 'status' in data['currentTask'] and 'type' in data['currentTask']:
                # A task's status can be 'new', 'running', 'success', 'error', or 'canceled'
                status = data['currentTask']['status']
                type_ = data['currentTask']['type']
                if status == 'new' or status == 'running':
                    # We will try again
                    self.current_task = data['currentTask']
                elif status == 'canceled':
                    # Message will be in response error
                    # TESTME: will we ever get here, or will exception be thrown first?
                    self.current_task = None
                elif status == 'error':
                    # Message will be in response error
                    # TESTME: will we ever get here, or will exception be thrown first?
                    self.current_task = None
                elif status == 'success':
                    # Fetch non-error result
                    self.current_task = None
                    if 'result' in data['currentTask'] and data['currentTask']['result'] is not None:
                        result = data['currentTask']['result']
                        if type_ == 'space':
                            self.gen = result['campaign']['gen']
                            self.remaining = result['campaign']['remaining']
                            self.completed = result['campaign']['completed']
                            self.validated_params = result['params']
                        elif type_ == 'generate':
                            self.gen = result['campaign']['gen']
                            self.remaining = result['campaign']['remaining']
                            self.completed = result['campaign']['completed']
                            self.design = result['experiments']
                        elif type_ == 'finalize':
                            self.gen = result['campaign']['gen']
                            self.remaining = result['campaign']['remaining']
                            self.completed = result['campaign']['completed']
                        elif type_ == 'simulate':
                            self.gen = result['campaign']['gen']
                            self.remaining = result['campaign']['remaining']
                            self.completed = result['campaign']['completed']
                            self.validated_params = result['params']
                            self.experiments_history = result['experimentsHistory']
            if self.current_task is not None:
                self.current_task['pollRetries'] = retries + 1
        else:
            print('No current task was found!')
            print('Error: {}'.format(self.error_messages(errors)))
            data = {'currentTask': None}
            self.current_task = None

        return (data, errors)

    def wait_for_current_task(self, timeout=None):
        """Wraps poll_for_current_task in a loop. Repeat until task disappears,
        when `status` is `success` or `failure`.

        # Arguments
        timeout (float):
            Maximum number of seconds to wait.

        # Returns
        None.
        """
        retry = 0
        if timeout is not None:
            timeout = time.time() + timeout
        while (timeout is None or retry == 0 or time.time() <= timeout):
            data, errors = self.poll_for_current_task()
            if data and 'currentTask' in data and data['currentTask'] is not None:
                if data['currentTask']['status'] == 'error':
                    if retry > 0:
                        sys.stdout.write('\n')
                    print('Task had an error!  Messages are:')
                    errors = data['currentTask']['errors']
                    for ee in errors[0]:
                        print(ee, '\t', errors[0][ee])
                    return

                retry += 1
                mystr = '\rTask status = {} after {} retries...'.format(data['currentTask']['status'], retry)
                sys.stdout.write(mystr)
                sleep(1.0)
            else:
                if retry > 0:
                    print('\nTask completed successfully.')
                else:
                    print('No current task!')
                return

    def get_validated_experimental_space(self, timeout=5*60):
        """Utility method to retrieve the validated experimental space from
        the session. If the session was restarted and the experimental space
        had been previously validated, it will be in the `validated_params`
        attribute, and this method will return it. If the space was saved,
        and the "space" task is still running, invoking this method will poll
        until either the timeout is reached, or the space result is returned.

        # Arguments
        timeout (int):
            The maximum number of seconds that the client will poll the session
            for a result. The default is 300 (5 minutes).

        # Returns
        dict:
            The validated space, a Python dict with `type`, and `table` keys, and
            a `totalUnits` key if the space type is "mixture".
        """

        if self.validated_params is not None:
            return self.validated_params['space']

        tmax = time.time()
        if timeout is not None and timeout > 0:
            tmax += timeout

        while True:
            data, errors = self.poll_for_current_task('space')
            if 'currentTask' in data and data['currentTask'] is not None:
                type_ = data['currentTask']['type']
                if type_ == 'space':
                    status = data['currentTask']['status']
                    if status == 'success' and self.validated_params is not None:
                        return self.validated_params['space']
                    elif status != 'new' and status != 'running':
                        raise TaskFailedError('space')
                else:
                    raise TaskTypeError('space')
            else:
                raise NoCurrentTaskError()
            if tmax < time.time():
                raise TaskTimeoutError()
            time.sleep(1.0)


    def get_generated_design(self, gen=None, timeout=30*60):
        """Utility method to retrieve a design generation from
        the session. If the session was restarted and the design for the
        specified generation number is available, it will be in the `design`
        attribute, and this method will return it. If the "generate" task
        is still running, invoking this method will poll until either the
        timeout is reached, or the design result is returned.

        # Arguments
        gen (int):
            The generation number for the design to be retrieved.

        timeout (int):
            The maximum number of seconds that the client will poll the session
            to retrieve the generated design. The default is 1800 (30 minutes).

        # Returns
        dict:
            The generated design, a Python dict representing an experiments table
            with empty responses with `colHeaders`, and `data` keys.
        """

        if self.validated_params is None or (gen is not None and gen < 0):
            raise SessionParametersNotValidatedError()

        if gen is None:
            if self.design is not None:
                return self.design
            else:
                gen = self.gen + 1
        if gen > 0 and self.gen >= 0 and self.design is not None:
            if gen == self.gen:
                return self.design
            elif gen != self.gen + 1:
                raise NextGenerationError(self.gen + 1)

        tmax = time.time()
        if timeout is not None and timeout > 0:
            tmax += timeout
        while True:
            data, errors = self.poll_for_current_task('generate')
            if 'currentTask' in data and data['currentTask'] is not None:
                type_ = data['currentTask']['type']
                if type_ == 'generate':
                    status = data['currentTask']['status']
                    if status == 'success' and self.design is not None:
                        return self.design
                    elif status == 'error':
                        errors = data['currentTask']['errors']
                        print('Task had an error!  Messages are:')
                        for ee in errors[0]:
                            print(ee, '\t', errors[0][ee])
                        raise TaskFailedError('generate task errors: {}'.format(errors))
                    elif status != 'new' and status != 'running':
                        raise TaskFailedError('generate task status is {}'.format(status))
                else:
                    raise TaskTypeError('generate')
            else:
                raise NoCurrentTaskError()
            if tmax < time.time():
                raise TaskTimeoutError()
            time.sleep(1.0)

    def get_analytics(self, timeout=30):
        """Get a list of the available analytics files for the session.

        # Arguments
        timeout (int):
            The maximum number of seconds that the client will wait for a
            response from the session. The default is 30 seconds.

        # Returns
        dict:
            The JSON response from the gql request, a Python dict with `createAnalytics` and/or
            `errors` keys. If there are any files available, they will be returned in the
            `createAnalytics` value as a Python dict. The `createAnalytics` dict will have
            two keys:

        gen (int):
            The current generation number in the session, for which the files were created.

        files (list):
            A list of the availiable files. Each file is represented by a Python dict
            with the following keys:

        title (str):
            The title (description) for the file.

        filename (str):
            The default file name that can be passed to the `save_analytics_file` method.

        url (str):
            The public URL from which to fetch the file.
        """

        vars = {
            'sessionId': self.session_id,
        }

        # The 'createAnalytics' mutation generates PDF files on the Rserve
        # server, and returns the titles and file names for these PDF files.
        # To download one or more of these files, another query (not tested here)
        # will be used.
        doc = gql.gql("""
mutation CreateAnalytics($sessionId:String!) {
    createAnalytics(sessionId:$sessionId) {
        gen files {
            title filename url
        }
    }
}
        """)
        return self.gql.execute(doc, variable_values=vars, timeout=timeout)

    def save_analytics_file(self, url, save_as=None):
        """Fetch the contents of an analytics file. Once a URL to a particular analytics file
        has been obtained using the `get_analytics` method, use this method to request the
        file's contents over HTTP.

        # Arguments
        url (str):
            The URL for the file, as returned from `get_analytics` method.

        save_as (str):
            If supplied, save the file's contents to this file system location.
            The location must be writable by the calling user.

        # Returns
        requests.Response:
            The `requests` library's `response` object for the authenticated HTTP request.
        """

        response = requests.get(url, auth=self.auth)
        if save_as is not None and response.status_code == requests.codes.ok and response.content is not None:
            with open(save_as, "wb") as pdf_file:
                pdf_file.write(response.content)
        return response

    def save_all_analytics_files(self, directory=".", timeout=30):
        """For each available analytics file, fetch its contents and save it as a file in the
        specified directory.

        # Arguments
        directory (str):
            If supplied, the target directory to save the files to. If the directory
            does not exist, attempt to create it.

        timeout (int):
            The maximum number of seconds that the client will wait for a
            response from the session. The default is 30 seconds.

        # Returns
        int:
            The number of files created.
        """

        nfiles = 0
        path = os.path.abspath(directory)
        data = self.get_analytics(timeout=timeout)
        if 'createAnalytics' in data:
            for file_info in data['createAnalytics']['files']:
                response = requests.get(file_info['url'], auth=self.auth)
                if response.status_code == requests.codes.ok and response.content is not None:
                    if nfiles == 0:
                        os.makedirs(path, exist_ok=True)
                    save_as = os.path.join(path, file_info['filename'])
                    with open(save_as, "wb") as pdf_file:
                        pdf_file.write(response.content)
                        nfiles += 1

        return nfiles

    def export_csv(self, fname, table, headers=True):
        """Utility method to write an expeimental space or experiments table to
        a CSV file on disk.

        # Arguments
        fname (str):
            The filesystem path where the file will be written.

        table (dict):
            A Python dict with `colHeaders` and `data` values, representing an
            experimental space or experiments table.

        headers (bool):
            If False, no header row will be written (this is the standard for
            experimental space CSV files). If True, the header row will be
            written to the file.

        # Returns
        Nothing
        """

        if table is not None and 'data' in table:
            with open(fname, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile, delimiter=',', quoting=csv.QUOTE_NONE)
                if headers and 'colHeaders' in table and table['colHeaders'] is not None:
                    writer.writerow(table['colHeaders'])
                if table['data'] is not None:
                    for row in table['data']:
                        writer.writerow(row)

    def export_validated_experimental_space_csv(self, fname, timeout=5*60):
        """Retrieves the validated experimental space table and writes the table to
        a CSV file on disk.

        # Arguments
        fname (str):
            The filesystem path where the file will be written.

        timeout (int):
            The maximum number of seconds that the client will poll the session
            to retrieve the experimental space. The default is 300 (5 minutes).

        # Returns
        dict:
            A Python dict representing the validated experimental space.
        """

        space = self.get_validated_experimental_space(timeout)
        self.export_csv(fname, space['table'], False)
        return space

    def export_initial_experiments_template_csv(self, fname, timeout=5*60):
        """Retrieves the validated experimental space table and writes an
        empty initial experiments table to a CSV file on disk.

        # Arguments
        fname (str):
            The filesystem path where the file will be written.

        timeout (int):
            The maximum number of seconds that the client will poll the session
            to retrieve the experimental space. The default is 300 (5 minutes).

        # Returns
        list:
            The experiments table header row that was written to disk, as a list of strings.
        """

        space = self.get_validated_experimental_space(timeout)
        col_headers = self.experiments_table_column_names(space)
        self.export_csv(fname, {'colHeaders': col_headers, 'data':[]})
        return col_headers

    def export_generated_design_csv(self, fname, gen = None, timeout=30*60):
        """Retrieves a design generation from the session, and writes the
        experiments table (with empty responses) to a CSV file on disk.

        # Arguments
        fname (str):
            The filesystem path where the file will be written.

        gen (int):
            The generation number for the design to be retrieved.  Default current
            generation.

        timeout (int):
            The maximum number of seconds that the client will poll the session
            to retrieve the generated design. The default is 1800 (30 minutes).

        # Returns
        dict:
            The generated design, a Python dict representing an experiments table
            with empty responses with `colHeaders`, and `data` keys.
        """

        if gen is None:
            gen = self.gen

        design = self.get_generated_design(gen, timeout)
        self.export_csv(fname, design['table'])
        return design

    def export_experiments_history_csv(self, fname):
        """Retrieves and returns the experiments and responses for all generations in the session,
        and writes them to a summary CSV file on disk. Also updates the `experiments_history`
        attribute in the client.

        # Arguments
        fname (str):
            The filesystem path where the file will be written.

        timeout (int):
            The maximum number of seconds that the client will poll the session
            to retrieve the generated design. The default is 1800 (30 minutes).

        # Returns
        list or None:
            The value of the client's `experiments_history` attribute, which may be
            None if no experiments have been submitted or designed, or is a list of dicts.
            Each item in the list is a Pythoon dict that represents a generation
            (the first item is generation "zero", the initial experiments, etc.) with the
            following keys:


        """

        self.get_experiments_history()
        history = self.experiments_history
        if history is not None and len(history) > 0:
            with open(fname, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile, delimiter=',', quoting=csv.QUOTE_NONE)
                seq = 0
                for gen, exp in enumerate(history):
                    if exp is not None:
                        if seq == 0:
                            writer.writerow(['Seq_', 'Gen_', 'Designed_'] + exp['table']['colHeaders'])
                        drows = exp['designRows']
                        for i, row in enumerate(exp['table']['data']):
                            seq += 1
                            designed = 'Y' if i < drows else 'N'
                            writer.writerow([seq, gen, designed] + row)

        return history

    def space_table_value_column_name(self, space_type, i):
        """Utility method to format a header column name for in an
        experimental space table.

        # Arguments
        space_type (str):
            "mixture" or "factorial"

        i (int):
            Index of the value column (starting at zero).

        # Returns
        str:
            "Min" or "Max" for a "mixture" space type, or "Value.1", "Value.2", etc.
            for a "factorial" space type.
        """

        if space_type == 'mixture':
            if i == 0:
                return 'Min'
            elif i == 1:
                return 'Max'
        return 'Value.{0}'.format(i + 1)

    def space_table_column_names(self, space):
        """Generates the canonically formatted column header names for
        the experimental space table.

        # Arguments
        space (dict):
            A Python dict that defines the experimental space.

        # Returns
        list:
            A list of strings to build the column header for an experimental space.
            The list will contain "Name", "Type", "Min" and "Max" for a "mixture" space,
            or "Name", "Type", "Value.1", "Value.2", etc. for a "factorial" space.
        """

        params = space['table']['data']
        if len(params) > 0:
            space_type = space['type']
            n_value_cols = len(params[0]) - 2
            value_cols = [ self.space_table_value_column_name(space_type, i) for i in range(0, n_value_cols) ]
            return [ 'Name', 'Type' ] + value_cols
        return []

    def experiments_table_column_names(self, space):
        """Generates the required header for the experiments table, including the
        names of each parameter in the experimental space, and the reserved name
        "Response" for the experiment response value.

        # Arguments
        space (dict):
            A Python dict that defines the experimental space.

        # Returns
        list:
            The list is made up from the names of all parameters, and the additional
            string "Response".
        """

        params = space['table']['data']
        if len(params) > 0:
            param_names = [param[0] for param in params]
            return param_names + ['Response']
        return []

    def experiment_with_random_response(self, experiment, max_response_value):
        """Uses a random number generator to generate a numerical response value
        in the range [0, n] and then replaces any existing response value with
        the generated value.

        # Arguments
        experiment (list):
            A list of values representing an experiment, including a (possibly
            empty) response value.

        max_response_value (float):
            The maximum random response value to be generated for the experiment.

        # Returns
        list:
            The list of parameter values for the specified experiment, with a generated
            response value. Each value is encoded as a string.
        """

        response = '{:.3f}'.format(random.uniform(0.0, max_response_value))
        new_experiment = experiment[0:-1]
        new_experiment.append(response)
        return new_experiment

    def random_parameter_value(self, space_type, param):
        """Uses a random number generator to select a parameter value that is valid
        for the space type and specified parameter definition.

        # Arguments
        space_type (str):
            The space type, either "mixture" or "factorial".

        param (list):
            The row from the experimental space definition table that defines
            a particular parameter in the space (name, type, and min / max or
            allowed values for the parameter). Each element in the list is
            encoded as a string.

        # Returns
        str:
            A valid value for the parameter, encoded as a string.
        """

        if len(param) < 4:
            raise InvalidParameterError(space_type, param)
        if space_type == 'mixture':
            if param[1] != 'unit':
                raise InvalidParameterError(space_type, param)
            min_value = int(param[2])
            max_value = int(param[3])
            return str(random.randint(min_value, max_value))
        else:
            if param[1] not in ['factorial', 'numerical']:
                raise InvalidParameterError(space_type, param)
            values = [s for s in param[2:] if s != '']
            return random.choice(values)

    def random_experiment_for_space(self, space, max_response_value=None):
        """Uses a random number generator to select parameter values and
        optionally to create a random response value.

        # Arguments
        space (dict):
            A Python dict that defines the experimental space.

        max_response_value : None or float
            If None, the experiment is generated with an empty response.
            If a number, the response value is a randomly generated number
            in the range [0.0, max_response_value].

        # Returns
        str:
            A valid value for the parameter, encoded as a string.
        """

        space_type = space['type']
        params = space['table']['data']
        experiment = [self.random_parameter_value(space_type, param) for param in params] + ['']
        if max_response_value is not None:
            return self.experiment_with_random_response(experiment, max_response_value)
        return experiment

    def experiments_table_template(self, space):
        """Generate the column header for the experiments table, with no data
        rows. Can be used to export an empty experiments table template CSV file,
        or to submit "empty" initial experiments.

        # Arguments
        space (dict):
            A Python dict that defines the experimental space.

        # Returns
        dict:
            A Python dict with `colHeaders` and `data` values, representing an
            empty experiments table.
        """

        col_headers = self.experiments_table_column_names(space)
        if col_headers is None:
            raise SpaceOrDesignRequiredError()
        return {'colHeaders': col_headers, 'data': [] }

    def random_experiments_with_responses(self, space, design, num_extras=0, max_response_value=5.0):
        """Generate an experiments table with where each experiment row
        contains a randomly generated response value. The experiment rows
        are optionally  composed of "designed" rows and "extra" rows.
        The "designed" rows have one experiment row for each row in the
        currently generated design. And the "extra" rows contain randomly
        generated parameter values as well as responses.

        # Arguments
        space (dict):
            A Python dict that defines the experimental space.

        design (dict): or None
            If supplied, a Python dict that defines the currently generated
            design as a table. The dict has `colHeaders` and `data` keys.

        num_extras: int
            If non-zero, generate this number of extra rows. The extra rows
            will be appended to any designed rows.

        max_response_value : float
            The maximum value for generated responses. Each genreated response value
            is a randomly generated number in the range [0.0, max_response_value].

        # Returns
        dict:
            A Python dict with `colHeaders` and `data` values, representing an
            experiments table.
        """

        col_headers = None
        designed_experiments = []
        extra_experiments = []
        if space is not None:
            col_headers = self.experiments_table_column_names(space)
            if num_extras > 0:
                extra_experiments = [self.random_experiment_for_space(space, max_response_value) for i in range(0, num_extras)]
        if design is not None:
            col_headers = design['table']['colHeaders']
            designed_experiments = [self.experiment_with_random_response(experiment, max_response_value) for experiment in design['table']['data']]
        if col_headers is None:
            raise SpaceOrDesignRequiredError()
        return { 'colHeaders': col_headers, 'data': designed_experiments + extra_experiments }
