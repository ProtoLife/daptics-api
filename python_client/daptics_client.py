#!/usr/bin/env python3

"""DapticsClient - A Python client for the Daptics GraphQL API.

See comments and docstrings for the DapticsClient class in the code below
for suggestions for using this class. For additional help or information,
please visit or contact Daptics.

On the web at https://daptics.ai
By email at support@daptics.ai

Daptics API Version 0.4.1
Copyright (c) 2019 Daptics Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), the
rights to use, copy, modify, merge, publish, and/or distribute, copies of
the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

You do not have the right to sub-license or sell copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""


import csv
import gql
import gql.transport.requests
import json
import pprint
import requests
import requests.auth
import time


class TokenAuth(requests.auth.AuthBase):
    """A callable authentication object for the Python "requests" moudule.
    If acess token is set, add a "Bearer" authorization header to the HTTP request.

    Attributes
    ----------
    token : str
        An acess token obtained from the API for the authenticated user.
    """
    def __init__(self):
        self.token = None

    def __call__(self, r):
        """Insert the authorization header as a bearer token.
        """
        if self.token is not None:
            r.headers['Authorization'] = 'Bearer ' + self.token
        return r


class NoCurrentTaskError(Exception):
    def __init__(self):
        self.message = 'There is no current task active in the session.'

class TaskTypeError(Exception):
    def __init__(self, type_):
        self.message = 'The current task is not of the the requested {} task type.'.format(type_)

class TaskTimeoutError(Exception):
    def __init__(self):
        self.message = 'The current task did not complete within the timeout duration.'

class TaskFailedError(Exception):
    def __init__(self, type_):
        self.message = 'The {} task failed to return a valid result.'.format(type_)

class SessionParametersNotValidatedError(Exception):
    def __init__(self):
        self.message = 'The session parameters have not been validated.'

class NextGenerationError(Exception):
    def __init__(self, gen):
        self.message = 'The next requested generation must be {}.'.format(gen)

class CsvFileEmptyError(Exception):
    def __init__(self, fname):
        self.message = 'No rows were found in the file {}.'.format(fname)

class CsvNoDataRowsError(Exception):
    def __init__(self, fname):
        self.message = 'No data rows were found in the file {}.'.format(fname)


class DapticsClient(object):
    """A Python gql client for maintaining the state of a Daptics optimization session.
    Between API invocations, data such as the user id, access token, session id,
    last generated design, etc. are retained in the object's attributes.

    Attributes
    ----------
    host : str
        The host part of the API endpoint.
    api_url : str
        The full API endpoint URL.
    pp : PrettyPrinter object
        Used for printing dict output.
    gql : gql.Client object
        The gql.Client object used to make GraphQL requests to the API.
    auth : TokenAuth object
        Used to insert the required authorization header in API requests. The
        auth object's `token` attribute is set by the `login` method.
    user_id : str
        The user id for the authenticated user, set by the `login` method.
    session_id : str
        The session id for a connected PDT session, as set by the `create_session` method.
    current_task : dict
        Information about a running task in the session.
    gen : int
        The design "generation number" for the session. This is -1 for a new session,
        0 when the session's experimental space has been validated, and greater than
        zero when a design has been generated by the system.
    initial_params : dict
        The experimental space and other information as initially returned by the
        `create_session` method.
    space : dict
        The experimental space as updated by the result of the "save experimental space" task.
    design : dict
        The current generated design as updated by the result of a "generate design" task.
    """
    def __init__(self, host):
        """Initialize a new DapticsClient object.

        Parameters
        ----------
        host : str
            The host part of the API endpoint. Example: `http://localhost:4041`
        """
        self.host = host
        self.api_url = '{0}/api'.format(host)
        self.pp = pprint.PrettyPrinter(indent=4)
        self.gql = None
        self.auth = TokenAuth()
        self.user_id = None
        self.session_id = None
        self.current_task = None
        self.gen = -1
        self.initial_params = None
        self.validated_params = None
        self.design = None

    def save(self, fname):
        """Save the user and session id to a JSON file.

        Parameters
        ----------
        fname : str
            The file path to save the client state to.

        Returns
        -------
        Nothing
        """
        with open(fname, 'w') as outfile:
            data = {
                'user_id': self.user_id,
                'token': self.auth.token,
                'session_id': self.session_id
            }
            json.dump(data, outfile, ensure_ascii=False, indent=4)

    def load(self, fname):
        """Restore a previously saved client from a JSON file.

        Parameters
        ----------
        fname : str
            The file path to restore the client state from.

        Returns
        -------
        Nothing
        """
        self.auth = TokenAuth()
        self.user_id = None
        self.session_id = None
        self.current_task = None
        self.gen = -1
        self.initial_params = None
        self.validated_params = None
        self.design = None
        with open(fname, 'r') as infile:
            data = json.load(infile)
            if 'user_id' in data and data['user_id'] is not None:
                self.user_id = data['user_id']
                if 'token' in data and data['token'] is not None:
                    self.auth.token = data['token']
                if 'session_id' in data and data['session_id'] is not None:
                    self.session_id = data['session_id']

    def connect(self):
        """Create an HTTP transport instance from the client's `api_url` attribute,
        and attempt to connect to the introspection interface. The gql.Client
        value is stored in the client's `gql` attribute.

        Returns
        -------
        Nothing

        Raises
        ------
        requests.ConnectionError
            If the connection cannot be made.
        """
        if self.gql is None:
            http = gql.transport.requests.RequestsHTTPTransport(
                self.api_url, auth=self.auth, use_json=True)
            self.gql = gql.Client(transport=http, fetch_schema_from_transport=True)

    def login(self, email, password):
        """Authenticate to a user record in the database as identified in the client's
        `email` and `password` attributes, and create an access token.

        Parameters
        ----------
        email : str
            The email adddress of the database user that will be used for authentication.
        password : str
            The cleartext password of the database user that will be used for authentication.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `login` and/or
        `errors` keys. On successful authentication, the user id and access token
        are stored in the client's `user_id` and `auth` attributes.
        """
        vars = {
            'email': email,
            'password': password
        }

        # The 'login' mutation authenticates a user's email and password and returns
        # an access token that self.auth will then use to add an Authorization
        # header, required for session queries and mutations.
        doc = gql.gql("""
mutation Login($email:String!, $password:String!) {
    login(email:$email, password:$password) {
        token user {
            userId
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'login' in data and data['login'] is not None:
            self.auth.token = data['login']['token']
            self.user_id = data['login']['user']['userId']
        return data


    def create_session(self, name, description, demo):
        """Create a new PDT session.

        Parameters
        ----------
        name : str
            The unique name for the session among the authenticated user's sessions.
        description : str
            A description for the session.
        is_demo : bool
            If True, this will be a demo session with simulated designs and responses.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `createSession` and/or
        `errors` keys. On successful creation, the session id and initial parameters
        are stored in the client's `session_id` and `initial_params` attributes.
        """
        vars = {
            'session': {
                'userId': self.user_id,
                'name': name,
                'description': description,
                'demo': demo
            }
        }

        # The 'createSession' mutation will add a new session to the backend's database,
        # copy runtime files to a fresh Rserve session directory on the Rserve filesystem,
        # start the session and return initial session information.
        doc = gql.gql("""
mutation CreateSession($session:NewSessionInput!) {
    createSession(session:$session) {
        sessionId version tag name description host path active demo campaign {
            gen remaining completed
        }
        params {
            validated populationSize replicates designCost space {
                type totalUnits table {
                    colHeaders data
                }
            }
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'createSession' in data and data['createSession'] is not None:
            self.session_id = data['createSession']['sessionId']
            self.initial_params = data['createSession']['params']
        return data

    def reconnect_session(self, session_id):
        """Find an existing session.

        Parameters
        ----------
        session_id : str
            The session id to find.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `createSession` and/or
        `errors` keys. On successful creation, the session id and initial parameters
        are stored in the client's `session_id` and `initial_params` attributes.
        """
        vars = {
            'sessionId': session_id
        }

        # The 'session' query will return the state of the session.
        doc = gql.gql("""
query GetSession($sessionId:String!) {
    session(sessionId:$sessionId) {
        sessionId version tag name description host path active demo campaign {
            gen remaining completed
        }
        params {
            validated populationSize replicates designCost space {
                type totalUnits table {
                    colHeaders data
                }
            }
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'session' in data and data['session'] is not None:
            session = data['session']
            self.session_id = session['sessionId']
            self.gen = session['campaign']['gen']
            self.initial_params = session['params']
            if self.gen >= 0:
                self.validated_params = session['params']
            else:
                self.validated_params = None
        return data

    def make_space_col_headers(self, params):
        """Format colHeaders canonically."""
        param_rows = params['space']['table']['data']
        if len(param_rows) > 0:
            n_value_cols = len(param_rows[0]) - 2
            col_headers = [ 'Name', 'Type'] + [ 'Value.{0}'.format(i + 1) for i in range(0, n_value_cols) ]
            params['space']['table']['colHeaders'] = col_headers
        return params

    def save_experimental_and_space_parameters(self, params):
        """Start a "save experimental space" task in the session, specifying the
        desired experimental space parameters.

        Parameters
        ----------
        params : dict
            A dictionary containing the experimental space parameters to be
            used for the session. See the Notes section that describes the
            required keys for the `params` dict.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveSessionParameters` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Notes
        -----
        Keys for the `params` dict are:

        populationSize : int
            The number of experiments per replicate. A positive integer.

        replicates : int
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space : dict
            The experimental space definition. Keys for the `space` dict are:

        type : str
            The type of the space, a string, either "factorial" or "mixture".

        totalUnits : int
            For `mixture` type spaces, this is the mixture constraint parameter,
            a non-negative integer.

        table : dict
            The (optional) column headers and rows of parameter data.  See
            an example below. the `colHeaders` value is ignored when importing
            or validating the experimental space definition.

            To maintain uniformity, header and data row elements should be
            Python strings, even if they represent numeric values.

            For `mixture` type spaces, there should only be 4 columns of data
            in each row: the name of the parameter, the type of the parameter
            (which must always be the string "unit"), the minimum value of the
            parameter (a non-negative integer) and the maximum value of the
            parameter (a positive integer, less than or equal to the `totalUnits`
            constraint parameter).

            For `factorial` type spaces, there must be at least 4 columns of data
            in each row: the name of the parameter, the type of the parameter
            (a string, either "numerical" or "categorical"), and at least
            two possible distinct values that the parameter can have in an experiment.
            Different parameters can have either 2 or more than 2 possible values.
            The rows must be all be of the same size, so make sure to pad the
            rows with fewer values with empty strings at the end.

        Examples
        --------
        Here is a mixture space design that will have enough combinations to be
        validated by the backend.

        params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'mixture',
                'totalUnits': 25,
                'table': {
                    'colHeaders':
                        [ 'Name', 'Type', 'Min', 'Max' ],
                    'data': [
                        [ 'param1', 'unit', '1', '10' ],
                        [ 'param2', 'unit', '2', '10' ],
                        [ 'param3', 'unit', '4', '8' ],
                        [ 'param4', 'unit', '2', '5' ]
                    ]
                }
            }
        }

        Here is a factorial space design that will have enough combinations to be
        validated by the backend.

        params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'factorial',
                'table': {
                    'colHeaders':
                        [ 'Name', 'Type', 'Value.1', 'Value.2', 'Value.3', 'Value.4' ],
                    'data': [
                        [ 'param1', 'numerical', '0', '1', '2', '3' ],
                        [ 'param2', 'numerical', '2', '3',  '',  '' ],
                        [ 'param3', 'numerical', '0', '1', '2',  '' ],
                        [ 'param4', 'numerical', '0', '1', '2', '3' ]
                    ]
                }
            }
        }
        """

        params_with_headers = self.make_space_col_headers(params)
        vars = {
            'sessionId': self.session_id,
            'params': params_with_headers
        }

        # The 'saveSessionParameters' mutation must be run to validate the
        # user's experimental design. The mutation will return errors if the
        # parameters or space are not valid (don't generate enough complexity, etc.).
        # If the parameters are valid, information about the long running 'space'
        # task is returned, and the user should poll until the task has completed.
        doc = gql.gql("""
mutation CreateSpaceTask($sessionId:String!, $params:SessionParametersInput!) {
    saveSessionParameters(sessionId:$sessionId, params:$params) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveSessionParameters' in data and data['saveSessionParameters'] is not None:
            self.current_task = data['saveSessionParameters']
            self.current_task['pollRetries'] = 0
        return data

    def save_experimental_and_space_parameters_csv(self, params, fname):
        """Start a "save experimental space" task in the session, specifying the
        desired experimental space parameters. The experimental space is
        read from a CSV file.

        Parameters
        ----------
        params : dict
            A dictionary containing the experimental space parameters to be
            used for the session. See the Notes section for more information.

        fname : str
            The location on the filesystem for a CSV file that will define
            the experimental space definition. See the Examples section
            below for an example.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveSessionParameters` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Raises
        ------
        csv.Error
            If the specified CSV file is incorrectly formatted.

        Notes
        -----
        Keys for the `params` dict are:

        populationSize : int
            The number of experiments per replicate. A positive integer.

        replicates : int
            The number of replicates. A non-negative integer. The total number of
            experiments per design generation is `populationSize * (replicates + 1)`.

        space : dict
            The experimental space definition. Keys for the `space` dict are:

        type : str
            `factorial` or `mixture`

        Examples
        --------
        Here is a space design that will have enough combinations to be
        validated by the backend.

        params = {
            'populationSize': 30,
            'replicates': 2,
            'space': {
                'type': 'factorial',
            }
        }

        The contents of an example CSV file for a `factorial` space might be:

        param1,numerical,0,1,2,3
        param2,numerical,2,3,4,
        param3,numerical,0,1,,
        param4,numerical,0,1,2,3

        Each parameter row in a factorial space definition should have the same
        number of columns.  Parameter rows with fewer than the maximum number of values
        should have the empty columns at the end of the row, as shown above.

        The contents of an example CSV file for a `mixture` space might be:

        param1,unit,0,10
        param2,unit,5,10
        param3,unit,0,10
        param4,unit,0,5

        Each parameter fow in a mixture space defintion must specify a minimum and
        maximum unit volume, as shown above.

        Do not supply a header row for the space definition (for any type), just the parameter
        rows.
        """

        datarows = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            datarows = [r for r in reader]
        params['space']['table'] = { 'data': datarows }
        return self.save_experimental_and_space_parameters(params)

    def get_experiments_col_headers(self, space):
        """Format colHeaders canonically."""
        param_names = [row[0] for row in space['table']['data']]
        return param_names + ['Response']

    def make_empty_experiments_table(self, timeout=5*60):
        space = self.get_validated_experimental_space(timeout)
        col_headers = self.get_experiments_col_headers(space)
        return {'colHeaders': col_headers, 'data': [] }

    def save_initial_experiments(self, experiments=None):
        """Save any initial experiments in the session and generate the first design.
        This method must be called to generate the first design, whether or not any
        experiments are submitted. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        Parameters
        ----------
        experiments : dict or None (default)
            If provided, a "table" of initial experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveExperiments` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Examples
        --------
            experiments = {
                'colHeaders': ['param1', 'param2', 'param3', 'param4', 'Response'],
                'data': [
                    ['0', '4', '1', '1', '3.25'],
                    ['1', '4', '1', '1', '4.5']
                ]
            }
        """

        if experiments is None:
            experiments = self.make_empty_experiments_table()
        vars = {
            'sessionId': self.session_id,
            'experiments': {
                'gen': 0,
                'table': experiments
            }
        }

        # The 'saveExperiments' mutation sends any initial or designed experiment
        # responses. For this demo we don't send any initial experiments.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation InitialExperiments($sessionId:String!, $experiments:ExperimentsInput!) {
    saveExperiments(sessionId:$sessionId, experiments:$experiments) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveExperiments' in data and data['saveExperiments'] is not None:
            self.current_task = data['saveExperiments']
            self.current_task['pollRetries'] = 0
        return data

    def save_initial_experiments_csv(self, fname):
        """Save any initial experiments in the session and generate the first design.
        This method must be called to generate the first design, whether or not any
        experiments are submitted. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        Parameters
        ----------
        fname : str
            The location on the filesystem for a CSV file that will define
            the intial experiments. See the Examples section
            below for an example.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveExperiments` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Raises
        ------
        csv.Error
            If the specified CSV file is incorrectly formatted.

        Examples
        --------
        Here are the contents for an initial experiments file, defining two initial
        experiments. A header row must be provided, the columns in the header row
        must match the names of the parameters defined by the experimental space definition
        exactly, and a final column named `Response` must be filled with the results
        of each experiment row.

        param1,param2,param3,param4,Response
        0,4,1,1,3.25
        1,4,1,1,4.5
        """

        experiments = None
        if fname is not None:
            rows = []
            with open(fname, newline='') as csvfile:
                reader = csv.reader(csvfile, delimiter=',')
                rows = [r for r in reader]
            nrows = len(rows)
            if nrows > 0:
                experiments = {
                    'colHeaders': rows[0],
                    'data': rows[1:]
                }
            else:
                raise CsvFileEmptyError()
        return self.save_initial_experiments(experiments)

    def get_experiments(self, gen=None):
        """Get the designed or completed experiments for the current or any
        previous generation.

        Parameters
        ----------
        gen : int
            The generation number to search for. Use 0 to specify initial
            experiments. Use None to search for the last designed generation.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `experiments` and/or
        `errors` keys. If `gen` is the current, non-zero generation number,
        updates the client's `design` attribute, so this method can be used to
        find the current design.
        """

        if gen is None:
            gen = self.gen
        vars = {
            'sessionId': self.session_id,
            'gen': gen
        }
        doc = gql.gql("""
query GetExperiments($sessionId:String!, $gen:Int!){
    experiments(sessionId:$sessionId, gen:$gen) {
        validated hasResponses designRows table {
            colHeaders data
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if gen == self.gen and gen > 0 \
            and 'experiments' in data and data['experiments'] is not None:
            self.design = data['experiments']
        return data

    def save_experiment_responses(self, experiments):
        """Save designed or extra experiments for the last designed generation in the session,
        and generate the next design. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        Parameters
        ----------
        experiments : dict
            A "table" of experiments that includes columns,
            defined in the `colHeaders` value of the table, for each of the defined
            space parameters, and a column named 'Response' to record the result of
            experiments.

            Each row in the `data` value for the table represents
            an individual experiment. There must be at least as many rows as
            the current design has, and the parameter values for these rows
            must match the design exactly. Additional "extra" experiment
            rows can also be provided.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveExperiments` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Examples
        --------
            experiments = {
                'colHeaders': ['param1', 'param2', 'param3', 'param4', 'Response'],
                'data': [
                    ['0', '4', '1', '1', '3.25'],
                    ['1', '4', '1', '1', '4.5'],
                    ... etc, matching generated design rows
                ]
            }
        """

        vars = {
            'sessionId': self.session_id,
            'experiments': {
                'gen': self.gen,
                'table': experiments
            }
        }

        # A 'saveExperiments' mutation for a designed generation ('gen' > 0) requires
        # responses for the designed generation (and any optional additional non-designed
        # experiments and their responses), sent in the 'table' variable.
        # In this demo we generate random responses for the designed experiments.
        # If the generation number and saved responses are valid, information
        # about the long running 'generate' task is returned, and the user should
        # poll until the task has completed.
        doc = gql.gql("""
mutation SaveExperiments($sessionId:String!, $experiments:ExperimentsInput!) {
    saveExperiments(sessionId:$sessionId, experiments:$experiments) {
        sessionId taskId status type startedAt
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'saveExperiments' in data and data['saveExperiments'] is not None:
            self.current_task = data['saveExperiments']
            self.current_task['pollRetries'] = 0
        return data

    def save_experiment_responses_csv(self, fname):
        """Save designed or extra experiments for the last designed generation in the session,
        and generate the next design. If the experments are successfully validated against the
        experimental space parameters, a "generate design" task is started.

        Parameters
        ----------
        fname : str
            The location on the filesystem for a CSV file that will define
            the results of the designed and any extra experiments. See the Examples section
            below for an example.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `saveExperiments` and/or
        `errors` keys. If the task was successfully started, the task information is stored
        in the client's `current_task` attribute.

        Examples
        --------

        A header row must be provided, the columns in the header row
        must match the names of the parameters defined by the experimental space definition
        exactly, and a final column named `Response` must be filled with the results
        of each experiment row.

        param1,param2,param3,param4,Response
        0,4,1,1,3.25
        1,4,1,1,4.5

        Each non-header row in the file represents an individual experiment. There must be at
        least as many experiment rows as the current design has, and the parameter values
        for these rows must match the design exactly. Additional "extra" experiment
        rows can also be provided.
        """
        experiments = { 'colHeaders': '', 'data': [] }
        rows = []
        with open(fname, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',')
            rows = [r for r in reader]
        if len(rows) > 1:
            experiments['colHeaders'] = rows[0]
            experiments['data'] = rows[1:]
        else:
            raise CsvNoDataRowsError()
        return self.save_experiment_responses(experiments)

    def poll_for_current_task(self, task_type=None):
        """If there is a currently running task saved in the client, poll the
        session to see if a result is ready.

        Parameters
        ----------
        task_type : str
            `space`, `generate`, or None. If None is supplied (the default), use the
            task id stored in the client.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `currentTask` and/or
        `errors` keys.

        If the current task was a "save experimental space" task and it successfully completed,
        the client's `gen` attribute is set to zero.

        If the current task was a "generate design" task and it successfully completed,
        the client's `gen` attribute is updated to a number greater than zero, and the
        design is stored in the client's `design` attribute.

        If either type of task completed or failed, the client's `current_task` attribute
        is reset to None.
        """

        retries = 0
        vars = {
            'sessionId': self.session_id,
            'taskId': None,
            'type': None
        }
        if task_type is None:
            task = self.current_task
            if task is None:
                return {
                    'currentTask': None,
                    'errors':  [
                        { 'message': 'No currently running task in client' }
                    ]
                }
            else:
                retries = task['pollRetries']
                vars['taskId'] = task['taskId']
        else:
            vars['type'] = task_type

        # Saving the experimental and space parameters will start a long running
        # 'space' task. Saving experimental responses will start a long running
        # 'generate' task. This function queries the backend to check the status
        # of the task based on the task type. If the task is still running, we
        # do nothing. If no task is found, or if the task has failed, we assert
        # an error. If the task has completed, we update self.gen
        # for 'space' and 'generate' task results, and save self.design
        # from a 'generate' task result.
        doc = gql.gql("""
query CurrentTask($sessionId:String!, $taskId:String, $type:String) {
    currentTask(sessionId:$sessionId, taskId:$taskId, type:$type) {
        taskId type status startedAt progress {
            message
        }
        errors {
            message category fatalError systemError
        }
        result {
            ... on SpaceTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
            }
            ... on GenerateTaskResult {
                type campaign {
                    gen remaining completed
                }
                params {
                    validated populationSize replicates designCost space {
                        type totalUnits table {
                            colHeaders data
                        }
                    }
                }
                experiments {
                    validated designRows table {
                        colHeaders data
                    }
                }
            }
        }
    }
}
        """)
        data = self.gql.execute(doc, variable_values=vars)
        if 'currentTask' in data and data['currentTask'] is not None \
            and 'status' in data['currentTask'] \
            and 'type' in data['currentTask']:
            # status can be 'new', 'running', 'success', 'error', 'cancelled'
            status = data['currentTask']['status']
            type_ = data['currentTask']['type']
            if status == 'new' or status == 'running':
                # We will try again
                self.current_task = data['currentTask']
            elif status == 'canceled':
                # Message will be in response error
                # TESTME: will we ever get here, or will exception be thown first?
                self.current_task = None
            elif status == 'error':
                # Message will be in response error
                # TESTME: will we ever get here, or will exception be thown first?
                self.current_task = None
            elif status == 'success':
                # Fetch non-error result
                self.current_task = None
                if 'result' in data['currentTask'] and data['currentTask']['result'] is not None:
                    result = data['currentTask']['result']
                    if type_ == 'space':
                        self.gen = result['campaign']['gen']
                        self.validated_params = result['params']
                    elif type_ == 'generate':
                        self.gen = result['campaign']['gen']
                        self.design = result['experiments']

        if self.current_task is not None:
            self.current_task['pollRetries'] = retries + 1
        return data

    def get_validated_experimental_space(self, timeout=5*60):
        if self.validated_params is not None:
            return self.validated_params['space']

        tmax = time.time()
        if timeout is not None and timeout > 0:
            tmax += timeout
        while True:
            data = self.poll_for_current_task('space')
            if 'currentTask' in data and data['currentTask'] is not None:
                type_ = data['currentTask']['type']
                if type_ == 'space':
                    status = data['currentTask']['status']
                    if status == 'success' and self.validated_params is not None:
                        return self.validated_params['space']
                    elif status != 'new' and status != 'running':
                        raise TaskFailedError('space')
                else:
                    raise TaskTypeError('space')
            else:
                raise NoCurrentTaskError()
            if tmax < time.time():
                raise TaskTimeoutError()
            time.sleep(1.0)

    def export_validated_experimental_space_csv(self, fname, timeout=5*60):
        space = self.get_validated_experimental_space(timeout)
        with open(fname, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile, delimiter=',', quoting=csv.QUOTE_NONE)
            for row in space['table']['data']:
                writer.writerow(row)
        return space

    def export_initial_experiments_template_csv(self, fname, timeout=5*60):
        space = self.get_validated_experimental_space(timeout)
        col_headers = self.get_experiments_col_headers(space)
        with open(fname, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile, delimiter=',', quoting=csv.QUOTE_NONE)
            writer.writerow(col_headers)
        return col_headers

    def get_generated_design(self, gen, timeout=30*60):
        if self.gen < 0:
            raise SessionParametersNotValidatedError()

        if gen is None:
            if self.design is not None:
                return self.design
            else:
                gen = self.gen + 1
        if gen > 0 and self.gen >= 0 and self.design is not None:
            if gen == self.gen:
                return self.design
            elif gen != self.gen + 1:
                raise NextGenerationError(self.gen + 1)

        tmax = time.time()
        if timeout is not None and timeout > 0:
            tmax += timeout
        while True:
            data = self.poll_for_current_task('generate')
            if 'currentTask' in data and data['currentTask'] is not None:
                type_ = data['currentTask']['type']
                if type_ == 'generate':
                    status = data['currentTask']['status']
                    if status == 'success' and self.design is not None:
                        return self.design
                    elif status != 'new' and status != 'running':
                        raise TaskFailedError('generate')
                else:
                    raise TaskTypeError('generate')
            else:
                raise NoCurrentTaskError()
            if tmax < time.time():
                raise TaskTimeoutError()
            time.sleep(1.0)

    def export_generated_design_csv(self, gen, fname, timeout=30*60):
        design = self.get_generated_design(gen, timeout)
        if design is not None:
            with open(fname, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile, delimiter=',', quoting=csv.QUOTE_NONE)
                writer.writerow(design['table']['colHeaders'])
                for row in design['table']['data']:
                    writer.writerow(row)
        return design

    def get_analytics(self):
        """Get a list of the available analytics files for the session's current
        generation number.

        Returns
        -------
        The JSON response from the gql request, a Python dict with `createAnalytics` and/or
        `errors` keys. If there are any files available, the list of files will be
        returned in the `createAnalytics` value.  Each file will have a `url` and
        `filename` value, that can be passed to the `get_analytics_file` method.
        """
        vars = {
            'sessionId': self.session_id,
            'gen': min(self.gen, 0)
        }

        # The 'createAnalytics' mutation generates PDF files on the Rserve
        # server, and returns the titles and file names for these PDF files.
        # To download one or more of these files, another query (not tested here)
        # will be used.
        doc = gql.gql("""
mutation CreateAnalytics($sessionId:String!, $gen:Int!) {
    createAnalytics(sessionId:$sessionId, gen:$gen) {
        gen files {
            title filename url
        }
    }
}
        """)
        return self.gql.execute(doc, variable_values=vars)

    def get_analytics_file(self, url, save_as=None):
        """Fetch the contents of an analytics file. Once a URL to a particular analytics file
        has been obtained using the `get_analytics` method, use this method to request the
        file's contents over HTTP.

        Parameters
        ----------
        url : str
            The URL for the file, as returned from `get_analytics` method.
        save_as : str
            If suppled, save the file's contents to this file system location.
            The location must be writable by the calling user.

        Returns
        -------
        The "Requests" library's `response` object for the authenticated HTTP request.
        """
        response = requests.get(url, auth=self.auth)
        if save_as is not None and response.status_code == requests.codes.ok and response.content is not None:
            with open(save_as, "wb") as pdf_file:
                pdf_file.write(response.content)
        return response
